package com.dafei1288.jimsql.jdbc.protocol;

import com.dafei1288.jimsql.common.protocol.MessageType;
import com.dafei1288.jimsql.common.protocol.ProtocolFrame;
import com.dafei1288.jimsql.jdbc.JqConnection;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

public class JspV1Statement implements Statement {
  private final JqConnection conn;
  private final JspV1Wire wire;
  private int fetchSize = 0;
  private int lastUpdateCount = -1;

  public JspV1Statement(JqConnection conn) throws SQLException {
    this.conn = conn;
    try {
      String wirelog = conn.getInfo().getProperty("wirelog");
      if (wirelog == null || wirelog.isEmpty()) wirelog = System.getProperty("jimsql.wirelog");
      this.wire = new JspV1Wire(conn.getClientSocket(), wirelog);
      String db = conn.getInfo().getProperty("db");
      String user = conn.getInfo().getProperty("user");
      this.wire.ensureHello(db, user);
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

  @Override
  public ResultSet executeQuery(String sql) throws SQLException {
    try {
      boolean openCursor = fetchSize > 0;
      wire.query(sql, openCursor, fetchSize, 0);
      // Expect HEADER then END
      ProtocolFrame header = wire.readFrame();
      int t0 = header.header.type & 0xFF;
      if (t0 == MessageType.ERROR.code) {
        throw new SQLException("Server error: " + new String(header.payload, StandardCharsets.UTF_8));
      }
      if (t0 != MessageType.RESULTSET_HEADER.code) {
        throw new SQLException("Expected RESULTSET_HEADER");
      }
      String headerJson = new String(header.payload, StandardCharsets.UTF_8);
      return new JspV1ResultSet(wire, headerJson, fetchSize);
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }

    @Override
  public int executeUpdate(String sql) throws SQLException {
    boolean hasRs = execute(sql);
    if (hasRs) throw new SQLException("Query returned a result set");
    return (lastUpdateCount < 0) ? 0 : lastUpdateCount;
  }
  @Override public void close() {}
  @Override public int getMaxFieldSize() { return 0; }
  @Override public void setMaxFieldSize(int max) {}
  @Override public int getMaxRows() { return 0; }
  @Override public void setMaxRows(int max) {}
  @Override public void setEscapeProcessing(boolean enable) {}
  @Override public int getQueryTimeout() { return 0; }
  @Override public void setQueryTimeout(int seconds) {}
  @Override public void cancel() {}
  @Override public SQLWarning getWarnings() { return null; }
  @Override public void clearWarnings() {}
  @Override public void setCursorName(String name) {}
    @Override
  public boolean execute(String sql) throws SQLException {
    try {
      this.lastUpdateCount = -1;
      boolean openCursor = false;
      wire.query(sql, openCursor, 0, 0);
      ProtocolFrame f = wire.readFrame();
      int type = f.header.type & 0xFF;
      if (type == MessageType.ERROR.code) {
        throw new SQLException("Server error: " + new String(f.payload, StandardCharsets.UTF_8));
      }
      if (type == MessageType.UPDATE_COUNT.code) {
        String js = new String(f.payload, StandardCharsets.UTF_8);
        int i = js.indexOf("\"rows\":");
        int val = 0;
        if (i >= 0) {
          int p = i + 7; int e = p; while (e < js.length() && Character.isDigit(js.charAt(e))) e++;
          try { val = Integer.parseInt(js.substring(p, e)); } catch (Exception ignore) {}
        }
        this.lastUpdateCount = val;
        return false;
      }
      if (type == MessageType.RESULTSET_HEADER.code) { return true; }
      this.lastUpdateCount = 0; return false;
    } catch (IOException e) {
      throw new SQLException(e);
    }
  }
  @Override public ResultSet getResultSet() { return null; }
  @Override public int getUpdateCount() { return (lastUpdateCount < 0) ? 0 : lastUpdateCount; }
  @Override public boolean getMoreResults() { return false; }
  @Override public void setFetchDirection(int direction) {}
  @Override public int getFetchDirection() { return 0; }
  @Override public void setFetchSize(int rows) { this.fetchSize = rows; }
  @Override public int getFetchSize() { return this.fetchSize; }
  @Override public int getResultSetConcurrency() { return 0; }
  @Override public int getResultSetType() { return 0; }
  @Override public void addBatch(String sql) {}
  @Override public void clearBatch() {}
  @Override public int[] executeBatch() { return new int[0]; }
  @Override public java.sql.Connection getConnection() { return conn; }
  @Override public boolean getMoreResults(int current) { return false; }
  @Override public ResultSet getGeneratedKeys() { return null; }
  @Override public int executeUpdate(String sql, int autoGeneratedKeys) { return 0; }
  @Override public int executeUpdate(String sql, int[] columnIndexes) { return 0; }
  @Override public int executeUpdate(String sql, String[] columnNames) { return 0; }
  @Override public boolean execute(String sql, int autoGeneratedKeys) { return false; }
  @Override public boolean execute(String sql, int[] columnIndexes) { return false; }
  @Override public boolean execute(String sql, String[] columnNames) { return false; }
  @Override public int getResultSetHoldability() { return 0; }
  @Override public boolean isClosed() { return false; }
  @Override public void setPoolable(boolean poolable) {}
  @Override public boolean isPoolable() { return false; }
  @Override public void closeOnCompletion() {}
  @Override public boolean isCloseOnCompletion() { return false; }
  @Override public <T> T unwrap(Class<T> iface) { return null; }
  @Override public boolean isWrapperFor(Class<?> iface) { return false; }

}





